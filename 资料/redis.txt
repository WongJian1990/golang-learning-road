1.解决秒杀库存,APP首页访问等流量高峰，传统关系型数据库很容易被打崩
2.redis是非关系型数据库,是一种高性能的内存数据库,可以用作数据库、缓存、消息中间件等
3.redis支持10W QPS的并发，由于存储在内存中读写速度非常快
4.redis采用单进程单线程、是线程安全的、采用IO多路复用机制。
5.redis采用单线程,为什么这么快，
一: 因为redis使用内存存储，大部分请求属于内存操作，速度非常快，性能瓶颈不在cpu,而是在内存带宽和网络带宽
二:使用类似HashMap存储,使得查找操作的时间复杂读为O(1)
三:采用单线程的好处，可以避免不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不存在锁带来的性能消耗
四:使用多路复用IO模型，非阻塞IO
6.Redis的数据类型
字符串(String)\字典(Hash)\列表(List)\集合(Set)\有序集合(SortedSet)
7.redis 大量的key设置同一时间过期需要防止大量key的过期时间过于集中,导致过期时间点到redis出现卡顿现象，严重可能会出现
缓存雪崩现象。处理方法最好在需要的时间上加一个随机值，让过期时间分散开来
(电商首页经常使用定时任务刷新和缓存，可能导致大量的数据失效时间都十分集中，如果这个时间点大量客户涌入，就有可能导致缓存雪崩)
8.redis分布式锁， 先使用setnx来争锁，抢到之后再使用expire给锁加一个过期时间防止锁忘记释放
9.如果setnx之后执行expire之前进程意外crash或者重启需要怎么做，想办法让这两步合并为一步执行，可以使用set将这两条指令合并执行
10.加入redis里面有1亿个key,其中有10w个key是以固定的前缀开头的，如何全部找出 使用keys指令可以扫出指定模式的key列表
11.如果redis正在给线上业务提供服务，这个时候使用keys指令，由于redis单线程的缘故，会导致阻塞，线上服务停顿， 直到执行完毕，服务恢复
可以使用scan指令用于非阻塞式提取指定模式的keys列表，但是可能有重复，所以查询完需要去重操作
12.redis异步队列 使用list结构作为队列 rpush生产消息 lpop消费消息 当lpop没有消息需要sleep也可以使用blpop阻塞等待
13.redis可以使用pub/sub主题订阅的方式实现1:N的消息队列，但在消费者下线的情况下，生产的消息会丢失,这个时候使用RocketMQ专业的消息队列框架，可以实现亿级消息堆叠
14.redis可以使用sortedset实现延时队列， 用消息内容作为key， 时间戳作为score来生产消息，消费者使用zrangebyscroe来获取N秒之前的数据轮询进行处理
15.redis持久化 RDB(全量)和AOF(增量) 两者配合使用,RDB耗时较长，定时保存，停机会导致大量的数据丢失，AOF同步写指令，可以设置sync时间，控制数据丢失情况
16.RDB的原理fork一个子进程然后进行copy on write 子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写藏的页面数据会逐渐和子进程分离
17.Pipeline可以将多次IO的往返时间缩减为一次，前提是pipeline执行指令之间没有因果相关性 使用redis-benchmark进行压测可以发现影响redis的QPS峰值
的一个重要因素是pipeline批次指令的数目
18.Redis主从同步。第一次同步时主节点做一次bgsave,并同时将后续修改操作记录到内存buffer，待完成之后将RDB文件全量同步到复制节点，复制节点接收完成后
将RDB镜像加载到内存，加载完成后， 再通知主节点将期间修改的操作记录同步到复制节点进行重放完成同步过程。后续增量的数据通过AOF日志同步即可。
19.Redis集群 Redis Sential着眼于高可用，再master宕机的时候自动将slave提升为master,继续提供服务 Redis Cluster着眼于扩展性,在单个redis内存不足时，使用Cluster进行分片存储

20.主从复制
redis单节点存在单点故障，为了解决单点问题，一般需要对redis配置从节点， 然后使用哨兵来监听主节点的存活状态， 如果主节点挂掉，
从节点能继续提供缓存功能

主从配置结合哨兵(Sential)能解决单点问题，提高redis的可用性。从节点仅提供都操作，主节点提供写操作，对于读多写少可以给主节点配置多个从节点来提高
响应效率

21.主从同步过程
1)从节点执行slaveof[masterip][masterport]保存主节点信息 2)从节点中的定时任务发现主节点信息，建立和主节点的socket连接
3)从节点发送ping信号，主节点返回pong,两边互相通信 4)连接建立后主节点将所有数据发送给从节点(数据同步)
5)主节点将当前的数据同步给从节点后，完成复制建立的过程， 接下来主节点会持续的把写命令发送给从节点，保证主从数据的一致性

22.redis的过期策略和内存淘汰机制
redis采用定期删除+惰性删除策略 、内存淘汰策略

redis使用常见问题
1.缓存和数据库双写一致性问题
一致性问题还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。前提是如果对数据有强一致性要求，不能放缓存。
我们所做的一切，只能保证最终一致性。另外，我们所做的方案从根本上来说，只能降低不一致发生的概率。
因此，有强一致性要求的数据，不能放缓存。
首先，采取正确更新策略，先更新数据库，再删缓存。
其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

2.缓存雪崩问题
缓存雪崩解决方案：
给缓存的失效时间，加上一个随机值，避免集体失效。
使用互斥锁，但是该方案吞吐量明显下降了。
双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。
自己做缓存预热操作。然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；
A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。

3.缓存击穿问题
缓存穿透解决方案：
利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。
没得到锁，则休眠一段时间重试。
采用异步更新策略，无论 Key 是否取到值，都直接返回。
Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。
需要做缓存预热(项目启动前，先加载缓存)操作。
提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。
迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。


4.缓存并发竞争的问题
解决方案：
Redis事务操作，但不适合Redis集群操作.
抢分布式锁，不保证顺序性,但是可以通过添加时间戳，解决这个问题

5.消息队列实现异步解耦流量消峰填谷