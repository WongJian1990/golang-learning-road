1.解决秒杀库存,APP首页访问等流量高峰，传统关系型数据库很容易被打崩
2.redis是非关系型数据库,是一种高性能的内存数据库,可以用作数据库、缓存、消息中间件等
3.redis支持10W QPS的并发，由于存储在内存中读写速度非常快
4.redis采用单进程单线程、是线程安全的、采用IO多路服用机制。
5.redis采用单线程,为什么这么快，
一: 因为redis使用内存存储，大部分请求属于内存操作，速度非常快，性能瓶颈不在cpu,而是在内存带宽和网络带宽
二:使用类似HashMap存储,使得查找操作的时间复杂读为O(1)
三:采用单线程的好处，可以避免不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不存在锁带来的性能消耗
四:使用多路服用IO模型，非阻塞IO
6.Redis的数据类型
字符串(String)\字典(Hash)\列表(List)\集合(Set)\有序集合(SortedSet)
7.redis 大量的key设置同一时间过期需要防止大量key的过期时间过于集中,导致过期时间点到redis出现卡顿现象，严重可能会出现
缓存雪崩现象。处理方法最好在需要的时间上加一个随机值，让过期时间分散开来
(电商首页经常使用定时任务刷新和缓存，可能导致大量的数据失效时间都十分集中，如果这个时间点大量客户涌入，就有可能导致缓存雪崩)
8.redis分布式锁， 先使用setnx来争锁，抢到之后再使用expire给锁加一个过期时间防止锁忘记释放
9.如果setnx之后执行expire之前进程意外crash或者重启需要怎么做，想办法让这两步合并为一步执行，可以使用set将这两条指令合并执行
10.加入redis里面有1亿个key,其中有10w个key是以固定的前缀开头的，如何全部找出 使用keys指令可以扫出指定模式的key列表
11.如果redis正在给线上业务提供服务，这个时候使用keys指令，由于redis单线程的缘故，会导致阻塞，线上服务停顿， 直到执行完毕，服务恢复
可以使用scan指令用于非阻塞式提取指定模式的keys列表，但是可能有重复，所以查询完需要去重操作
12.redis异步队列 使用list结构作为队列 rpush生产消息 lpop消费消息 当lpop没有消息需要sleep也可以使用blpop阻塞等待
13.redis可以使用pub/sub主题订阅的方式实现1:N的消息队列，但在消费者下线的情况下，生产的消息会丢失,这个时候使用RocketMQ专业的消息队列框架，可以实现亿级消息堆叠
14.redis可以使用sortedset实现延时队列， 用消息内容作为key， 时间戳作为score来生产消息，消费者使用zrangebyscroe来获取N秒之前的数据轮询进行处理
15.redis持久化 RDB(全量)和AOF(增量) 两者配合使用,RDB耗时较长，定时保存，停机会导致大量的数据丢失，AOF同步写指令，可以设置sync时间，控制数据丢失情况
16.RDB的原理fork一个子进程然后进行copy on write 子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写藏的页面数据会逐渐和子进程分离
17.Pipeline可以将多次IO的往返时间缩减为一次，前提是pipeline执行指令之间没有因果相关性 使用redis-benchmark进行压测可以发现影响redis的QPS峰值
的一个重要因素是pipeline批次指令的数目
18.Redis主从同步。第一次同步时主节点做一次bgsave,并同时将后续修改操作记录到内存buffer，待完成之后将RDB文件全量同步到复制节点，复制节点接收完成后
将RDB镜像加载到内存，加载完成后， 再通知主节点将期间修改的操作记录同步到复制节点进行重放完成同步过程。后续增量的数据通过AOF日志同步即可。
19.Redis集群 Redis Sential着眼于高可用，再master宕机的时候自动将slave提升为master,继续提供服务 Redis Cluster着眼于扩展性,在单个redis内存不足时，使用Cluster进行分片存储